\chapter{Sprint: 3}
Following sprint 2 where we focused on improving the stability of the underlying
libraries of GIRAF, this sprint will have the same focus as there are still a
lot of issues with the build tools. This means that some tasks could not be
resolved as these are dependent on Artifactory. As such, the goals of the sprint
are the same as last sprint, see \label{Sprint2UserStories}, and have been
defined as follows:\nl

\say{Continuous integration need to be fully functional, such that gradle can
handle JAVA libraries correctly.}\nl

\say{Improve stability in libraries, accessibility, and usability for apps, to
fulfill user stories 1, 4 and 6.}\nl

\say{Server and client library, continue implementation of functionality for
user stories 2, 3 and 4.}\nl

During the second week of this sprint, our build tools (Artifactory and
Jenkins) were repaired. Based on this breakthrough, our purpose in this sprint
has been redefined to implementing new features based on the requirements found
in \label{sec:Colab2}, and testing the changes committed during the first and
second sprint. 

\section{Tasks and Solutions}
Based on the requirements found in \label{sec:Colab2}, and the need to
implementing the REST server communication framework developed by SW613 and
SW615, we have been assigned the tasks shown in \autoref{Tasks3}.

\begin{table}[H]
\begin{centering}
\begin{tabular}{|l|p{9cm}|l|}
\hline
Number 	& Description & Man-hours \\ \hline
T634   	& Wiki: Continually update Launcher info on the wiki & 8\\\hline
T728  	& Pictoreader refactoring. & 60 \\ \hline
T739	& Wiki: Document Weekplanner and Pictosearch & 64\\ \hline
T785	& Handle crash such that the user does not get an error message and is
		  brought back to the launcher & 6\\ \hline
T786 	& Check if an app can be set to grayscale globally & 10\\ \hline
T800 	& Discuss how models should be implemented group SW609, SW610, SW613 and
		  SW615. & 16\\ \hline
T822 	& Implement grayscale functionality & 4\\ \hline
T830 	& Hide error splash screen and seperate it from analytics & 2\\ \hline
T832 	& Upload libraries to Artifactory & 12\\ \hline
T833 	& Update build scripts to use new Artifactory libraries & 2\\ \hline
T834 	& Implement new login screen (Beta branch) & 2\\ \hline
T835 	& Implement model-view-controller structure & 4\\ \hline
T836 	& Remove deprecated libraries/implement the new REST libraries & 60\\
\hline T837 	& Rework buttons to not use listeners & 6\\ \hline
\end{tabular}
\caption{Tasks for the third sprint}
\label{Tasks3}
\end{centering}
\end{table}

\subsection{T785, T830 - Prevent stack-trace from showing for
users}\label{T785-T830} 
Based on general feedback, we have been tasked with making sure that the
detailed error messages are not shown to the users. The users have requested
this, as the citizen users are confused/uncomfortable with the large amount of
incomprehensible information being suddenly shown on the screen whenever an
error occurs.\nl

In task T672 in \autoref{T672}, we replaced the system for sending crash logs to
Google Analytics, such that whenever the bug splash screen was shown, it would
forward the exception and its message. As the users no longer want to be shown
the splash screen, we have simply decoupled the two from each other. The revised
code can be seen below in \autoref{BugsplNew}. On line 15 we attempt to recreate
the activity which crashed, as this was a requested feature.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = We use Google Analytics and try to recreate the activity, label = BugsplNew] 
protected void onCreate(final Bundle savedInstanceState) 
{ 
...
	final Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler =
    	Thread.getDefaultUncaughtExceptionHandler();

        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread thread, final Throwable ex) {

                // Sends the exception to google analytics
                sendExceptionToGoogleAnalytics(ex);

                // Restarts the activity Todo find out if it restarts the launcher or at least work
                recreate();
            }
        });
...
}
\end{lstlisting}
\end{minipage}

\subsection{T786, T822 - Research and implement grayscale functionality}
Based on user story 2, which is shown in \autoref{UserStoriesGeneral}, we have
been tasked with researching how it would be possible to make a global
implementation of grayscale in the GIRAF project.\nl

Following our research, we came up with three different approaches to
implementing grayscale:

\begin{enumerate}
  \item Create an alternative set of resources for all giraf components, which
  make use of a grayscale color scheme.
  \item Apply an opaque layer to all GIRAF applications, which would make all
  components less colorful and more gray.
  \item Reduce the saturation of all GIRAF component's colors, such that all
  applications would look gray.
\end{enumerate}

Based on the fact that we want to create a global option which is forward
compatible with future GIRAF applications, and the fact that we want
to minimize the amount of added resources, we have chosen the third
option, which is to change the saturation of all GIRAF applications.\nl

We have chosen to implement the grayscale functionality in the
\textc{giraf-component-lib} library, as this library is included in all GIRAF
applications. As such, the core of the implementation is made in the class
\textc{GrayScaleHelper}. Changing a given screen to grayscale consists of two
steps; changing the activity, and changing the action bar at the top.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Code used to determine the views for the activity and the top action bar., label = grayEx1] 
public class GrayScaleHelper
{

    public static void setGrayScaleForActivity(Activity activity, boolean shouldBeGray){
        View screen = activity.getWindow().getDecorView();
        int barId = activity.getResources().getIdentifier("action_bar_container", "id", "android");
        View bar = screen.findViewById(barId);
        View view = activity.findViewById(android.R.id.content);
        setGray(view,shouldBeGray);
        setGray(bar,shouldBeGray);
    }
...
}
\end{lstlisting}
\end{minipage}

As can be seen in \autoref{grayEx1}, the first step is to identifying the
\textc{views} containing the \textc{activity} and the top \textc{action bar}
respectively. The method \textc{setGrayScaleForActivity} takes a reference to
the \textc{activity}, and a boolean determining if the \textc{activity}
should be grayscale. On \textbf{line 5}, the \textc{view} for the background
\textc{android} screen is retrieved. On \textbf{line 6}, the ID for the
\textc{action bar} is determined. On \textbf{line 7}, the \textc{view} for the
\textc{action bar} is determined based on the ID. On \textbf{line 8}, the
\textc{view} for the \textc{activity} is determined. Finally on \textbf{lines 9-10}, the \textc{setGray}
method is called with the \textc{view} for the \textc{activity} and the
\textc{action bar} respectively. The \textc{setGray} method can be seen in
\autoref{grayEx2}.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Method used to change to color saturation of views., label = grayEx2]
public class GrayScaleHelper {
...
    private static void setGray(View view, boolean state){
        if(state) {
            ColorMatrix cm = new ColorMatrix();
            cm.setSaturation(0); //Set the color saturation to 0
            Paint grayscalePaint = new Paint();
            grayscalePaint.setColorFilter(new ColorMatrixColorFilter(cm));
            // Create a hardware layer with the greyscale paint
            view.setLayerType(LAYER_TYPE_HARDWARE, grayscalePaint);
        }else{
            //Removes the grayscale
            view.setLayerType(LAYER_TYPE_NONE, null);
        }
    }
}
\end{lstlisting}
\end{minipage}

In the \textc{setGray} metod in \autoref{grayEx2}, we first use the boolean
\textc{state} to determine if we should set the \textc{view} to grayscale. This
boolean represents the value of a \textc{switch button} in the settings menu,
which indicates if the option is turned on or off. \textbf{Lines 5-8} are used
to create an android \textc{Paint}, which has the color saturation of value
zero. On \textbf{line 10}, a \textc{hardware layer} using the defined
\textc{paint} is added to the supplied \textc{activity}, see
\autoref{grayScale}.\nl

\figx[0.30]{grayScale}{An example of the grayscale in action}

In order for a given activity to implement grayscale, it needs to have a call to
the \textc{setGrayScaleForActivity} method. An example of this call is
implemented in the \textc{Launcher's HomeActivity} class and can be seen in
\autoref{grayEx3}.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Setting grayscale by calling the setGrayScaleForActivity method, label = grayEx3] 
private void setGrayscale(){
        SharedPreferences prefs = SettingsUtility.getLauncherSettings(this,
            LauncherUtility.getSharedPreferenceUser(currentUser));

        GrayScaleHelper.setGrayScaleForActivity(this, prefs.getBoolean(
            getString(R.string.toggle_gray_scale_preference_key), true));
    }
\end{lstlisting}
\end{minipage}

In \autoref{grayEx3}, we start by retrieving the GIRAF launcher's shared
preferences. We then use the boolean
\textc{toggle\_gray\_scale\_preference\_key's} value in the \\
\textc{setGrayScaleForThisActivity} method, to set grayscale for this
application. While not implemented yet, the intention is to supply the boolean
value to other GIRAF applications through the \textc{android intent}, which is
used to launch those applications.\nl

As stated above, in order to change the grayscale setting through the GUI, we
have added a \textc{switch button}. This settings menu with the added button can
be seen in \autoref{newSettingsPage}, where grayscale has been enabled. 

\figx[0.30]{newSettingsPage}{The switch as shown in the Launcher's settings
menu}


\subsection{T832, T833 - Upload new libraries to Artifactory and implement them}

Following the breakdown of Artifactory during the first sprint, group SW615 has
been working on restoring Artifactory to its intended state. Now, during the
third sprint, they have succeeded in their task, and Artifactory can now be
used.\nl

As stated in \autoref{GTools}, our collection of build tools used to work in the
following manner:
The developers committed the code to Git and then went to build it using
Jenkins. Jenkins would automatically retrieve the code from Git and compile it.
If Jenkins would succeed, it would then upload the compiled libraries to
Artifactory. Whenever a library was needed to build the software, both locally
and on Jenkins, a request would be sent to Artifactory, which would then return
the compiled library.\nl

With the current fix to our build setup, we have to build the libraries locally
on our own machines, and the upload them to Artifactory using a shared Gradle
build script, which the server infrastructure group (SW615) has created. This
build script can be seen in \autoref{ArtiBuild1} and \autoref{ArtiBuild2}. In
\autoref{ArtiBuild1}, on \textbf{lines 1-8} we download the Gradle-Artifactory
bridge plugin\citep{Gradle-Artifactory}. On \textbf{lines 9-11} we apply the
plugin, and use the maven-publish plugin, which allows us to publish to the
Maven repository. Then on \textbf{line 12} we specify the name of the library as
uploaded to Artifactory. Then on \textbf{lines 12-19} we specify the subfolders
on Artifactory which we want to upload the compiled libraries to.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Specifying file names and subfolder paths on Artifactory, label = ArtiBuild1] 
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1"
    }
}
apply plugin: 'com.jfrog.artifactory'
apply plugin: 'maven-publish'
group = "dk.aau.cs.giraf"
version = System.properties.VERSION ?: "1.0-SNAPSHOT" // Get version from the jenkins parameter VERSION
println "Version is ${version}"
repositories {
    maven {
        url 'http://jenkins.giraf.cs.aau.dk:8080/artifactory/libs-release'
    }
    maven {
        url 'http://jenkins.giraf.cs.aau.dk:8080/artifactory/libs-snapshot'
    }
}
\end{lstlisting}
\end{minipage}

Following the specification of paths and names, we run the publish command in
\autoref{ArtiBuild2} on \label{lines 3-19}. On \textbf{lines 5-7} we specify the
authentication information for Artifactory and the version number of the
uploaded files.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Publishing the compiled libraries to Artifactory, label = ArtiBuild2] 
artifactory {
    contextUrl = artifactory_contextUrl
    publish {
        repository {
            username = artifactory_user
            password = artifactory_password
            repoKey = version.endsWith('SNAPSHOT') ? 'libs-snapshot-local' : 'libs-release-local'
        }
        defaults {
            publications('artifacts')
            publishArtifacts = true
        }
    }
    resolve {
        repository {
            repoKey = 'jcenter'
        }
        repository {
            repoKey = 'libs-release'
        }
    }
}
\end{lstlisting}
\end{minipage}

This Gradle build-script has been distributed to all libraries, which allows us
to compile the libraries locally, and publish them to Artifactory for future
use.\\
In order to implement the new libraries from Artifactory, the Gradle
build scripts have been changed use both Artifactory's new Maven
repositories and also the new names of the libraries. In addition, we have made
sure that the application will always use the newest library versions, by
changing the retrieved library version to ``latest.integration''.\nl

The main problem encountered during this process has been, that some libraries
were unable to build correctly. During a build, these libraries would always
fail, and would report an error during
\textc{':app:transformClassesWithDexForDebug'}. The reported error specified
that the problem could potentially be solved by changing the target Java version
to Java 7. Following a further study of all the compiled libraries, we determined
that the error was caused by the \textc{meta-database} library having been
compiled with Java 8. As the rest of the GIRAF system is built upon Java 7, this caused
compatibility issues. After rebuilding the library with Java 7 compatibility, we
were able to build our applications without further problems.

\subsection{T834 - Implement new login screen}\label{LoginXML}
In order to implement the new login screen we used the design made in T731,
see \autoref{LoginScreen}, and adapted an existing unfinished design of
the login screen from a prior semester, see \autoref{OldNewLogin}. Their design
was intended to be implemented along with a profile selection screen in
a two-step fashion. This would allow the user to select their profile from
among their coworkers and then input their password afterwards \citep[Ch.9.5,
p.68-70]{RestLogin}. We chose to continue with our own design as it is
not intended to be used by citizens and can easier be expanded with more users.

\figx[1]{OldNewLogin}{The indevelopment design from the prior semester}

We modified it to include a \textc{textview} and an \textc{edittext} for
usernames, added a button to login, and changed the background to a more
suitable color, as can be seen in \autoref{NewNewLogin}.

\figx[1]{NewNewLogin}{The updated login screen design}

The design does not currently have any functionality as we are currently waiting
on the other groups to finish implementing their models for communication with
the server.

\subsection{Unfinished and Invalid Tasks}\label{S3Invalid}
\begin{itemize}
  \item T835 - Launcher: Implement model-view-controller
  \begin{itemize}
      \item The purpose of this task is to improve the quality of the GIRAF code
      base, by creating a logical distribution of responsibility among the different
      classes.
      \item While we have begun implementing the model-view-controller architecture
      on parts of the GIRAF GUI, we have not finished this task, as it represents
      an ongoing effort to refactor and improve the GIRAF code base.
  \end{itemize}
  \item T836 - Remove deprecated libraries/implement the new REST libraries
  \begin{itemize}
      \item The purpose of this task is to begin implementing the finished version
      of the REST library, which is responsible for handling the client-server
      communication.
      \item As this task covers a major development effort, we have chosen to split
      it into a number of new tasks, which will be completed during the 4th sprint.
      In addition, in relation to this task, this sprint has mostly been used to
      discuss the REST library and help the REST groups to implement all the needed
      functionality.  
      \end{itemize}
  \item T837 - Rework buttons to not use listeners
  \begin{itemize}
    \item The purpose of this task is to improve the quality of the GIRAF code
    base by removing the need for the GIRAF GUI to use listeners in order to
    execute methods on button presses. This can be done in a simpler and cleaner
    manner, by simple calling the methods from the GUI .xml files themselves.
    \item While we have begun implementing this approach on parts of the GIRAF
    GUI, we have not finished this task, as it represents an ongoing effort to
    refactor and improve the GIRAF code base.
  \end{itemize}
\end{itemize}

\section{Retrospective}
As with the former sprints, at the end of the third sprint, we held a meeting
with the other groups in order to reflect upon how the project is proceeding.\nl

The main problems with this sprint relate to the fact that our back-end was not
ready to be implemented for most of the sprint, and that our build tools
(Artifactory/Jenkins) did not work until about midway through the sprint.
This resulted in our group only being able to work on theoretical solutions and
implementations to our assigned tasks. When the build tools were finally able to
be used, we rushed to upload the newest libraries to Artifactory, and began
finalizing the solutions which we have been unable to test during the former
sprints.\nl

Following the build tools being functional, we began implementing the REST
libraries as well as removing the now deprecated \textc{db-lib} library. While
we were able to begin this process, at the time of the end of this sprint, the
REST libraries are not yet finished and are therefore incapable of completely
replacing the \textc{db-lib} library.

\subsection{Evaluation}
The sprint ended with 50.1\% of tasks being declared resolved, see
\autoref{Burndown3}. A lot of the remaining tasks remain open various reasons,
like in our case, they cannot be tested as we are currently working on
implementing the REST libraries. Many tasks were resolved in the last week as
they were locked behind other tasks.

\figx[0.5]{Burndown3}{The burndown chart for the third sprint}

