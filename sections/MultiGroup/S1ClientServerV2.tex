\chapter{REST Architectural Design}\label{S1CS}
This chapter covers a cooperative effort to make GIRAF use \textc{REST}, this
chapter covers several meetings held throughout the semester.\nl

The first meetings were held at the start of sprint and by SW609, SW610, SW613,
SW615. During these initial meetings, it was found that the existing
client/database communications system was incomplete and not of high enough
quality for us to dedicate development time to improve. The first of two main
issues were, that the existing system did not implement the required safety
measures which are expected of applications which make use of private
information. The second issue was, that the system did not allow for uploading
data to the server, but only to retrieve it, which rendered us unable to update
information on the server.\nl

Based on these issues, it was decided, that the groups responsible for the
database (SW613 and SW615) would be tasked to develop a new system, which should
make use of the principles described in the REST model (Representational State
Transfer)\citep{RESTInfo}. This model outlines a set of requirements which aim
to establish a high-quality framework for server-to-client communication. These
requirements are \citep{RESTInfo}:

\begin{itemize}
  \item Client-Server: Seperate the user interface from data storage and
  manipulation.
  \item Stateless: Each request to the server returns a response which contains
  all information required for the client to service the request.
  \item Cacheable: Responses from the server must implicitly or explicitly
  declare themselves as either cacheable or not, in order to prevent the client
  from reusing expired data.
  \item Layered System: The client is incapable of determining if it is connected
  to the main server or an affiliated intermediate entry point.
  \item Uniform Interface: The retrieved data is conceptually different from the
  representation used on the server. Given a set of data, the client should have
  enough information to edit and delete the respective information of the
  server. 
\end{itemize}

As a part of developing this new system, another meeting was held in order to further
determine the database resource requirements for the applications. Considering the
incomplete state of the previous system, this information was needed in order to
model the server and client libraries such that they would be able to transfer all
necessary data to the applications

\section{Requirement Analysis}
As our group (SW609) is responsible for the \texttt{Launcher} application and
the \\\texttt{pictosearch-lib} library, we were tasked with analyzing the
relevant code before the scheduled meeting, in order to determine what database resources
would be necessary for these applications/libraries. These tasks are presented
in \autoref{TaS1} as T636, T646, and T647.\nl

In our case, we mostly determined the requirements testing the \textc{Launcher}
and\\ \textc{pictosearch-lib} through general use. Based on this testing, and
analysis of the code, we determined the following requirements:\nl

In order to use the \textc{Launcher}, a user needs to login to an
\textc{account}, which is either a \textc{Guardian} or a \textc{Citizen}. Each
account has a \textc{name}, a \textc{picture}, an a \textc{unique identifier}.
In order to use \textc{pictograms} in applications, the system needs to access
pictogram objects by ID. As such, users require the following fields on the
server: \textbf{Name}, \textbf{UserID}, \textbf{Icon}, \textbf{Department},
\textbf{Username}, \textbf{Password}, \textbf{Screen Name}, and \textbf{Saved
Settings}.
Pictograms require the following fields on the database: \textbf{ID},
\textbf{Title}, and a \textbf{Bitmap (Picture)}.\nl

Based on a discussion with the other groups, we created a UML class diagram,
which has been subject to redefinitions throughout the project. The final
version of this diagram can be seen in \autoref{Giraf_RestModel}, where the
normal arrows imply inheritance, and the dotted lines imply implementation of an
interface.

\figx[0.65]{Giraf_RestModelV2}{UML class-diagram depicting the objects requested
from the database}

In the UML diagram shown in \autoref{Giraf_RestModel}, each class has a
specific use and responsibility. This is described below in
\autoref{restModelTableEh}.

\begin{table}[H] 
\begin{centering}
\begin{tabular}{|l|p{9cm}|l|}
\hline 
Class 					&	Description	\\ \hline
GirafObject				&	Used for inheritance for most other objects. Implements the
Serializable interface in order to allow it to be passed between applications. \\\hline 
User					&	Contains data about a single user and its planned
schedule and activities.\\\hline 
Department  			&	Used to differentiate users of
different institutions, which allows us to implement institution-specific information.\\\hline 
Settings    			&	Contains information about a users local settings. This allows
the same settings to be mirrored across multiple devices. \\\hline 
Role  			&	Used to specify the role of the user e.g. Admin,
Guardian, and Citizen.\\\hline 
Frame              		&   Acts as a container class for pictograms. Contains all
relevant contextual data, and a Pictogram object.\\\hline 
Choice              	&	Acts as a container class for pictograms like a Frame,
but contains multiple pictograms, in the case that the citizen has a choice between
multiple activities in their schedules. Choice does not allow to contain
Frames, because a choice should not be able to contain more choices.\\\hline
Pictogram & Contains a Bitmap image of the Pictogram.
\\\hline Day 					& 	Is a representation of a day and contains a enum which maps days
to integers \\\hline 
Progress 				& 	Is used to tell the progress of a pictogram in a week schedule
\\\hline 
Week 					& 	Contains weekdays and meta data such as which users this
week is for and the tumbnail for the week \\\hline 
Weekday              	&	A
Weekday is used to contain Frames for the week schedule.                  \\ \hline 
WeekdayActivity			& A relation between Weekdays and Frames such that additional
properties can be added.\\\hline 
WeekdayActivityProgress & 	Contains information about a users progress on a
given schedule.\\\hline 
Application    			&	Information about applications a user is allowed to access.\\\hline     
\end{tabular}
\caption{Classes used in the REST model, and their descriptions}\label{restModelTableEh}
\end{centering}
\end{table}

% \section{Client/Database Interface Design}
% Following the initial requirement analysis and the respective meetings, the
% database groups (SW613 and SW615) began designing the client/database interface.
% Towards the end of the first sprint, group SW612 held a meeting with the
% system's users, who defined a number of new requirements for the GIRAF
% applications. Based on the user's feedback, the database requirements that are
% relevant for our groups were further defined.
% 
% \begin{itemize}
%   \item We want to be able to change users' pictures by uploading new ones.
%   \item Pictograms should be retrieved in batches to decrease wait time.
%   \item Pictograms should be searchable by category.
%   \item In the Launcher, we only need direct access to guardians, as citizens
%   are aggregated from them.
%   \item We need a server timestamp in order to limit login sessions.
%   \item When accessing users, we need a sub-method to only retrieve ID, name, and
%   citizens, as we don't need all information.
% \end{itemize}
% 
% Based on these requirements, the database groups were able to further define
% the design of the client/database interface.\nl
% 
% Based on the meetings and discussion between our groups, the database groups
% (SW613 and SW615) formulated the following design for the interface, which
% should be used by the \textc{rest-models} library in order to retrieve and
% manipulate data from the database. This design can be seen in
% \autoref{interface-uml}. 
% 
% \figx{interface-uml}{UML diagram detailing the client/database interface.}
% 
% In order to describe the UML diagram, group SW613 supplied us with the following
% listing, which contains explanations for each of the diagram's elements. It
% should be noted that the following is presented verbatum as given to us by group
% group SW613.
% 
% \fix{}{Skal vi ikke bare fjerne den vi bruger den ikke til noget rigtigt og det
% er en hel side fra en anden gruppe.}
% 
% \colorbox{diff}{
% \begin{minipage}{\linewidth}
% The listings from group SW613F17.
% \begin{itemize}
%     \item \textbf{createSchedule}\\
%     The \texttt{createSchedule} function is called when a new schedule has been created on a device and the schedule should be synchronised across other devices connected to the same department.
%     \item \textbf{createImage}\\
%     This function is called when a user takes a photograph and wishes to share it across devices.
%     \item \textbf{readGuardianByDepartment}\\
%     The launcher application needs to read all guardian-objects from the current department. This function returns all guardians associated with the relevant department.
%     \item \textbf{readScheduleByCitizen}\\
%     This function returns all schedules associated with a given citizen.
%     \item \textbf{readPictogramByName}\\
%     When searching for pictograms, this function is used for getting pictograms by their name.
%     \item \textbf{readPictogramByQuery}\\
%     This function allows query passing to the database, allowing the application to search for pictograms with certain tags.
%     \item \textbf{updateGuardianImage}\\
%     This function and the following overloads modify the attributes of the given guardian object.
%     \begin{itemize}
%         \item \textbf{updateGuardianName}
%         \item \textbf{updateGuardianPhone}
%         \item \textbf{updateGuardianEmail}
%     \end{itemize}
%     \item \textbf{updateCitizenName}\\
%     This function and the following overloads modify the attributes of the given citizen object.
%     \begin{itemize}
%         \item \textbf{updateCitizenImage}
%         \item \textbf{updateCitizenPhone}
%         \item \textbf{updateCitizenEmail}
%     \end{itemize}
%     \item \textbf{updateScheduleAttribute}\\
%     This function and the following functions modify the given schedule object and sub-objects.
%     \begin{itemize}
%         \item \textbf{updateScheduleDay}
%         \item \textbf{updateScheduleFrame}
%         \item \textbf{updateScheduleChoice}
%     \end{itemize}
%     \item \textbf{deleteSchedule}\\
%     This function deletes a schedule object.
%     \item \textbf{deleteSchedules} (batch)\\
%     This function deletes a number of schedule object.
% \end{itemize}
% \end{minipage}
% }
% 
% 
% Until the REST framework is finished, the overall design of this interface
% will be used to identify what opportunities we have in the applications, when it
% comes to manipulating data on the database.

\section{Using the Rest Libraries}\label{UsingRest}
Following the final implementation of the REST model, the database groups SW613
and SW615 have supplied our group with a new approach to requesting and updating
information on the database. This approach consists of four different
elements: \textc{LoginRequest}, \textc{GetRequest}, \textc{ResourceRequest},
the \textc{RequestQueue} and the \ttt{RequestQueueHandler}.
An example of a \ttt{LoginRequest} can be seen in \autoref{CSLoginRequest1},
where we have two nested requests, a \textc{LoginRequest} and a
\textc{GetRequest<User>}.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Initial request the respective server response object, label = CSLoginRequest1]
queue = RequestQueueHandler.getInstance(gui.getApplicationContext()).getRequestQueue();

LoginRequest loginRequest = new LoginRequest(username, password,new Response.Listener<Integer>() 
{
	@Override
    public void onResponse(Integer statusCode) 
    {
    	GetRequest<User> userGetRequest = new GetRequest<User>(User.class, new Response.Listener<User>() 
    	{
        	@Override
            public void onResponse(User response) {
            	//Pass user to home Intent Extra and start the activity 
            	...
           	}
        }, new Response.ErrorListener() {
        	@Override
            public void onErrorResponse(VolleyError error) 
            {
            	//Show error message
            	...
            }
        });
        queue.add(userGetRequest);
    }
}, new Response.ErrorListener() {
	@Override
    public void onErrorResponse(VolleyError error) {
    	//Show error message
    	...
    }
});
queue.add(loginRequest);
}
\end{lstlisting}
\end{minipage}

In the code example in \autoref{CSLoginRequest1}, which comes from the
\ttt{LoginController} class, we start by creating a new \textc{LoginRequest} on
\textbf{line 3}, where we pass the users' \textc{username}, \textc{password},
the \textc{Response.Listener}, and the \ttt{Reponse.ErrorListener}. Here, the
latter two objects are used for handling the response we get from
the server.
If we succesfully get a response with a user on \textbf{line 8}, we then create
a \ttt{GetRequest<User>} which is a request that takes no parameters and returns
the user for the token/cookie we recived from the \ttt{LoginRequest}. Then on
\textbf{line 12} if we received a user, we can use this user to pass it to
the \ttt{Intent}'s \ttt{Extra}, and use it to start the \ttt{HomeActivity}. On
\textbf{line 23} we add the \ttt{userGetRequest} to the \ttt{queue}, such that
the request will only be executed if the login is succesful, and we have a
token/cookie. On the \textbf{lines 19 \& 28} we show an error message to the
user dependent on the error we recive from the \ttt{VolleyError}. This can be
seen in detail in \autoref{CSLoginRequest3}.\nl


\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Using an errorListener to detect mishaps in the LoginRequest, label = CSLoginRequest3] 
new Response.ErrorListener() 
{
	@Override
    public void onErrorResponse(VolleyError error) {
        int errorCode = error.networkResponse.statusCode;
        if (errorCode == 401) 
        {
        	//The username and/or password are incorrect
            gui.showDialogWithMessage(gui.getString(R.string.error_username_password));
        } else {
            //The server is for some reason unavailable
            gui.showDialogWithMessage(gui.getString(R.string.error_try_agian));
        }
    }
});

//The login request is added to the queue
queue.add(loginRequest);
\end{lstlisting}
\end{minipage}

The code example in \autoref{CSLoginRequest3} is the code which is represented
by the comment on \textbf{line 28} in \autoref{CSLoginRequest1}.
This method uses the network response returned on \textbf{lines 5 \& 6} to see
if we get a 401 status code. If we get such a code, on \textbf{line 9} we
display to the user that either the username or password was wrong. The same is
done on \textbf{line 12} but this time we only display a general ``Please try
again later'' message.


\subsection{REST Framework Discussion}
During development of the client-to-server communications framework, the server
groups SW613 and SW615 thought that it would be possible to wrap the server
communication requests inside a helper class, which would allow us to simply
call a number of methods whenever we wanted to manipulate/request data. This
however, has appeared to be impossible to do because SW613 did not succeed to
implement the REST client library in such a way that us application developers
should not work with the request and their response and error listener as we do
now. This has led to we needed to implement request chaining as shown in \autoref{CSLoginRequest1},
\autoref{CSLoginRequest2}, and \autoref{CSLoginRequest3} where we can use 50 or
more lines of code to retrieve a single user.\nl

Although the have made a handler which eliminates the need to instantiate the
request and add it to the queue. But we do still need to implement both
the onResponse and onError listener. So it removes 2 lines of code on average from
the request.\nl

If it was implemented as we discussed at the start of the development using
handlers and lambda-expressions we would be able to pass the methods that should
be called onReponse and onError to the handler and ideally if no method was
passed to onError it would handle the error.




% 
% This is because REST requires server communication to be asynchronous, such that UI threads are not put on hold while waiting for a
% response. The problem occours, as methods themselves are synchronous by
% definition, as control is only passed back to the calling class whenever the
% method returns. The necessity for asynchronous communication has limited us to
% using the approach shown in \autoref{CSLoginRequest1},
% \autoref{CSLoginRequest2}, and \autoref{CSLoginRequest3} where we can use 50 or
% more lines of code for a single request. The only solution we have found to this
% issue would be to use lambda-expressions, as they allow for us to pass methods
% as method parameters.
% This would allow us to pass two methods to the helper class, which would be used
% respectively on success and failure of the request. However, lambda-expressions
% are not currently available for Android development, as the current version of
% the Android SDK uses Java7, while lambda-expressions are only implemented from
% Java8 and onwards.













