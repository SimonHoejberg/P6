\chapter{Sprint: 01}
As this sprint represents the groups' initial experiences with the GIRAF
project, the purpose of this initial sprint is to gain a better understanding of
the inner workings of the various GIRAF apps, and to make sure that the quality
of the previosly written code is up to par. As such, the tasks for this sprint
are mostly superficial, but they do also include a number of fixes to critical
bugs.\nl

As part of the initial organization of the project, each group was assigned a
general area of responsibility. For our group, SW609, this responsibility
encompasses the apps \textc{Launcher} and \textc{Pictogram Searcher}. While
these apps represent our core responsibilities, not all of our tasks are
required to revolve around these apps.

\section{Tasks}
Based on our area of responsibility and the backlog from last semesters'
students, we have chosen an initial list of tasks, which can be seen below in
\autoref{SprintOneTasks}. 

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
Number 			& Task Description 											\\\hline
T620  			& Search: Identify unhandled exceptions.                 	\\\hline
T621    	   	& Launcher: Identify unhandled exceptions. 					\\\hline 
T623	       	& Search: Handle unhandled exceptions.                 		\\\hline
T624    	   	& Launcher: Handle unhandled exceptions.  					\\\hline
T625   	   		& Launcher: Evaluate possible exceptions.        			\\\hline
T626   	   		& Search: Evaluate possible exceptions.                		\\\hline
T629  	   		& Search: Refactor code.			   						\\\hline
T630       		& Launcher: Refactor code.                 					\\\hline
T631       		& Planner and Launcher: CheckStyle                 			\\\hline
T636			& Identify the weekplanner's dependencies.					\\\hline
T639       		& Disable visual elements.                 					\\\hline
T646       		& Identify necessary resources.                 			\\\hline
T647       		& Visualize client/server interface.                 		\\\hline 
T660       		& Solve the pictogram problem.                 				\\\hline
T670       		& Launcher: Fix crash on startup w/o internet or other apps.\\\hline
\end{tabular}
\caption{Tasks for the first sprint (Group SW609)} 
\label{SprintOneTasks}    
\end{table}

In the following subsections, we will elaborate upon each of the task, and
document what actions we have taken in order to resolve the issues.

\subsection{T620, T623, T626 - Search: Handle Exceptions}
Based on the backlog from the previous semester, we identified an unhandled
\\\textc{nullPointerException} in the \textc{PictoAdapter} class's
\textc{getView} method. This exception occurred when a used tried to enter a
comma into the pictogram search-bar. Due to faulty implementation, when the
search was executed on a comma, it returned an empty list of pictograms. Given
that the rest of the system never expects the pictogram list to be empty, this
led to a problem where the system tried to acces the first element of the list
which was null.\nl

In order to fix this problem, we have implemented multiple checks to make sure
that the system does not attempt to invoke any methods on the non-existing
object. Examples of these checks can be seen below in
\autoref{PictoListNullPoint}.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Newly implemented check for null values., label = PictoListNullPoint] 
...
final Object object = objectList.get(position);
Drawable catIndicator = context.getResources().getDrawable(R.drawable.icon_category);

if (convertView == null) {
	GirafPictogramItemView pictogramItemView;
    if (object != null && object instanceof Pictogram) {
    	Pictogram pictogramNew = (Pictogram) object;
        pictogramItemView = new GirafPictogramItemView(context, pictogramNew, pictogramNew.getName());
	} else if (object != null) {
	...
}
...
\end{lstlisting}
\end{minipage}

Checking the \textc{objectList} for null values solved the problem of trying to
access a non-existing object, but another problem is that the checked object is used to
modify and return a \textc{pictogramItemView}. As such, given the case where no
object exists, we need to identify if it is possible for the method to simply
return null or a dummy object. Through analysis of the
\textc{GirafPictogramItemView} class, we identified that the system is already
equipped to handle a \textc{pictogramItemView} with an uninitialized
\textc{imageEntity}. This can be seen below in \autoref{PictogramHandleNull}\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = \textc{setImageModel} method in the \textc{GirafPictogramItemView class.}, label = PictogramHandleNull] 
...
public synchronized void setImageModel(final ImageEntity imageEntity, final Drawable fallback) {
// If provided with null, do not update!
if (imageEntity == null) {
	return;
}
...
\end{lstlisting}
\end{minipage}

Based on this information, we have solved the problem by having the
\textc{getView} method return a newly made dummy object. This can be seen below
in \autoref{UnitImageEntity}.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Return dummy object in case of null-valued object., label = UnitImageEntity] 
...
if (convertView == null) {
	GirafPictogramItemView pictogramItemView;
    if (object != null && object instanceof Pictogram) {
    	...
    } else {
    	ImageEntity imageEntity = null; //The constructer doesn't accept a null as the second par 
    	pictogramItemView = new GirafPictogramItemView(context, imageEntity); 
  	}
...
\end{lstlisting}
\end{minipage}

\subsection{T621, T624, T670 - Launcher: Handle Exceptions}
During inspection of the Launcher's code, we identified two serious problems,
which both were capable of leading to crashes.

\subsubsection{LoadAnimation Crash}
The first problem was found in the launcher's \textc{MainActivity}, where a
global variable \textc{loadAnimation} was overshadowed by a local one defined in
the \textc{onCreate} method. As \textc{onCreate} is executed on creation of the
activity, the definition and assignment of \textc{loadAnimation} was contained
to this method, and the global variable was never initialized. This can be seen
below in \autoref{LoadAnimationCrash}. This problem led to a
\textc{nullPointerException} because the system tried to use an animation which
was not defined.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = The variable \textc{loadAnimation} is overshadowed locally., label = LoadAnimationCrash] 
public class MainActivity extends
GirafActivity implements Animation.AnimationListener, GirafNotifyDialog.Notification { ...
    private Animation loadAnimation;
    ...
    
	public void onCreate(Bundle savedInstanceState) {
		...	
    	Animation loadAnimation;
		...
	}
...
}    
\end{lstlisting}
\end{minipage}

This problem was fixed by removing the local definition of \textc{loadAnimation}
in the \textc{onCreate} method.

\subsubsection{Package Manager Crash}
The second problem was caused by a timer, which was used to ping the Android
package manager, in order to determine if changes were made to the device's
installed applications. This can be seen below in \autoref{PackageTimer}. The
problem occours when running the launcher on an emulator, because pinging the package
manager would return a empty list of installed applications. Based on our
observations, an empty app-list would prompt the system to ping the package
manager again each time an empty list was returned (which was always). Over
time, this constant pinging would overload the package manager, and cause an
unhandled \textc{deadObjectException}.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = The timer in the \textc{HomeActivity} class which pings the package manager., label = PackageTimer] 
private void startObservingApps() 
{ 
	appsUpdater = new Timer();
    AppsObserver timerTask = new AppsObserver();
    appsUpdater.scheduleAtFixedRate(timerTask, 5000, 5000);
 	...
}   	
\end{lstlisting}
\end{minipage}

This problem was fixed by implementing a new system to identify changes to the
list of installed applications. Instead of pinging the package manager on a
timer, we have implemented an Android \textc{broadcastListener}, which listens
for when the operating system broadcasts changes to the list of installed
applications. Otherwise, this listener is still set to execute the same code
that the previous timer would have. This new implementation can be seen below in
\autoref{broadcastListener}.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = New implementation of a \textc{broadcastReceiver}., label = broadcastListener] 
private void startObservingApps() {
	//Makes sure this Receiver is only registered once
    if(!appObserverReceiverRegistered) {
    	BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
        	appsChangedScan();
        }
    };
    //Sets up the filter to only trigger when these actions are
    received IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
    intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    registerReceiver(broadcastReceiver, intentFilter);
    appObserverReceiverRegistered = true;
    Log.d(Constants.ERROR_TAG, "Applications are being observed.");
	}
}
\end{lstlisting}
\end{minipage}

\subsection{T625 - Launcher: Evaluate Necessity of Present Exception Handling}
Placeholder\ldots

\subsection{T629, T630 - Search/Launcher: Refactor Code}
Shit was deleted, and keywords were changed when the code inspection tool (or
ourselves) said so.

\subsection{T631 - Planner and Launcher: CheckStyle}
In order to increase the quality and readability of the previously written code,
all the groups on this semester have chosen to make use of a generalized code
style, which will be enforced by the IntelliJ plugin CheckStyle.\\
As such, the purpose of this task is to used the CheckStyle plugin to identify
all instances where the code deviates from the agreed upon code style, and
manually refactor it such that the whole code base is uniformly written.\nl

When CheckStyle is executed on a project, it uses an XML file where the code
style is defined, to identify all cases where the code deviated from this
defined style. This information is presented in an ordered list. An example of
an error-list for the \textc{Launcher project} can be seen below in
\autoref{CodeStyleErrors}.

\figx[0.85]{CodeStyleErrors}{List of code style deviations in the Launcher
project.}

In order to solve the problems with the unsystematic code style, we have
methodically resolved the issues identified by CheckStyle.

\subsection{T646 - Identify Apps Required Resources}
\fix{}{Go ask the REST group for the UML diagram}

\subsection{T647 - Document Apps' Database Requirements}
\fix{}{Get DonF to write something. I was not at the meeting.}

\subsection{T660 - Decrease Pictogram Search-Time}
Through analysis of the problem, we have concluded that the pictogram search has
the possibility of having slow load times beacuase the server returns all
elements related to the search in one large package. This can result in a large
load time, as the program does not respond while waiting for the database to
send the package. \nl

In addition, because of the way the search functionality is
implemented, if a user is slow to write, the database receives multiple requests
for packages to send. As an example, if a user wants to find all pictograms
relating to \textc{cars}, the program may queue multiple requests: one for
all pictograms starting with \textc{c}, then for all pictograms starting with
\textc{ca}, and so on. This queueing of requests can make the program wait for a
very long time before responding.\nl

Due to the fact that main problem lies with the server sending all pictograms in
one large package, we have chosen to forward this task to the group responsible
for the server/database, namely group SW613. In addition, during a meeting with
the other groups, we recommended that the server might send the pictograms in
packages of 20 each, such that the user may receive feedback in the form of a
continously updating list of pictograms.
 
\subsection{Removed Tasks}
T626 - Search: Evaluate Necessity of Present Exception Handling\nl
T639 - Disable Problematic Visual Elements \nl
T636 - Weekplanner: Identify Functional Requirements \nl

% How did we identify the relevant tasks?
% Our focus area.
% Our Tasks.
% -----
% Solution of tasks
